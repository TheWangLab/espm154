---
title: "Population structure lab"
---

Today we are going to analyze population structure in western fence lizards (Sceloporus occidentalis) using a method known as TESS (Caye et al., 2016). TESS is a spatially explicit method that estimates population structure using ancestry coefficient estimates. We will use the algatr package to run TESS, which is a wrapper for the tess3r package. The algatr package provides a more user-friendly interface for running TESS, and also provides additional functionality for visualizing results.

First we need to load some libraries and install the required packages:

```{r}
library(algatr)
```

```{r, eval = FALSE}
# Install required packages
tess_packages()
```

```{r, warning = FALSE, message = FALSE}
library(here)
library(wingen)
library(tess3r)
library(ggplot2)
library(terra)
library(raster)
library(fields)
library(rworldmap)
library(automap)
library(cowplot)
library(sf)

# for plotting (from TESS)
source("http://membres-timc.imag.fr/Olivier.Francois/Conversion.R")
source("http://membres-timc.imag.fr/Olivier.Francois/POPSutilities.R")
```

Let's also load our data, which we will describe in more detail later:
```{r}
load_algatr_example()
```

### Read in and process input data

Running TESS3 requires three data files: a genotype dosage matrix (the `gen` argument), coordinates for samples (the `coords` argument), and environmental layers (the `envlayers` argument). We can use a VCF and the `vcf_to_dosage()` function to convert a VCF file to a dosage matrix.

A dosage matrix includes counts of alleles at each locus. For the data we are working with, all of the loci are biallelic, meaning therer are only two possible alleles at each locus: a reference allele and an alternate allele. This means you can get dosage values of either 0, 1, or 2 whereby 0 represents no copies of the alternate allele, 1 represents one copy of the alternate allele, and 2 represents two copies of the alternate allele. For example, let's say you had a let's say you have a reference allele "A" and an alternate allele "B", we can represent the dosage values as follows:
AA = 0
AB = 1
BB = 2

In our VCF, our genotypes are coded with 0 representing the reference ("A") and 1 representing the alternate ("B").
```{r}
# We can see the genotypes for the first 10 individuals and the first 10 loci using the following code:
liz_vcf@gt[1:10,1:10]
# Note that the rows are loci and the columns are individual lizards
``` 

Quesition 1: What would the dosage values be for the following genotypes?:
"0/0" = ?
"0/1" = ?
"1/1" = ?
"1/0" = ?

```{r dosage}
# Convert vcf to genotype matrix
liz_dosage <- vcf_to_dosage(liz_vcf)
liz_dosage[1:10, 1:10]
# Note that now the rows are individuals and the columns are loci
```

## Running TESS

Population structure methods describes genetic variation by assigning individuals according to numbers of clusters (K values). Given the "best" number of clusters, individuals are then given proportions to which they belong to each cluster. The number of clusters is oftern refered to as "K" and these proportions are known as ancestry coefficients, and can be interpreted as the proportion of an individual's ancestry belonging to different ancestral groups. There are many methods for estimating these ancestry coefficients; TESS is a unique method because it takes into account geography by using sample coordinates to incorporate spatial relationships into ancestry coefficient estimates.

### K-selection

A crucial part of population structure analysis is choosing the "best" number of clusters (K) for the data. We can test a range of K values using the `tess_ktest()` function. `tess_ktest()` runs TESS for a range of K values and outputs cross-validation scores for each values which which we can use to evaluate the "best" K for their dataset. Typically, researchers will select the "best" K value by minimizing cross-validation scores.

Here, we test K values 1 through 10. The `K_selection` argument specifies the method for selecting the best K value. We will be performing manual K selection (there is also an option for automatic K selection which we will ignore for now). The `ploidy` argument specifies the ploidy of the data, which is 2 for our diploids.

When we run the function, a cross-validation plot will appear and we will be prompted to select the best K value based on the cross-validation scores by entering a number in the console. The function will then return the TESS results for the best K value and the results from the cross-validation analysis.

How do you pick the best K-value? The cross-validation score is a measure of how well the model predicts the data. The lower the cross-validation score, the better the model is at predicting the data. However, as you will see, the cross-validation score tends to decrease as K increases becaues using more clusters to describe your sample often results in lower cross-validation error, so you want to pick the K value where the cross-validation score starts to level off. This is known as the "elbow" of the cross-validation plot. 

[ADD IMAGE]

In this plot, there is unfortunately not a clear elbow. This means that we will need to evaluate multiple K values and use other information for our population structure analysis. For now, let's select K = 3.

```{r auto K selection, message = FALSE, fig.align = 'center'}
tess_test <- tess_ktest(liz_dosage, liz_coords, Kvals = 1:10, K_selection = "manual", ploidy = 2)
```

### Looking at multiple values of K


Since our cross-validation analysis didn't give us a good idea of what K value to choose, let's look at the results for multiple K values. We can do this by looking at the results for multiple K values. First, let's get results for multiple K values:

```{r multiple K values, message = FALSE}
tess_result <- tess3(liz_dosage, coord = as.matrix(liz_coords), K = 1:10, ploidy = 2)
```

The key output from TESS is a matrix of ancestry coefficients, also known as Q-values. These values represent the proportion of ancestry assigned to each individual for each cluster (K value). We can extract these values using the `qmatrix()` function. Let's extract the Q values for K = 2 through K = 6:

```{r Q values}
qmat2 <- qmatrix(tess_result, K = 2)
qmat3 <- qmatrix(tess_result, K = 3)
qmat4 <- qmatrix(tess_result, K = 4)
qmat5 <- qmatrix(tess_result, K = 5)
qmat6 <- qmatrix(tess_result, K = 6)
```

We can visualize these Q values using a bar plot. The bar plot will show the proportion of ancestry assigned to each individual for each cluster (K value). Each bar represent an individual and the proportion of each color in the bar represents the proportion of ancestry for each individual. Let's look at the bar plots for K = 2 through K = 6:

```{r bar plots}
tess_barplot(qmat2)
tess_barplot(qmat3)
tess_barplot(qmat4)
tess_barplot(qmat5)
tess_barplot(qmat6)
```

We can use the Q values to assign the individuals to clusters. We can do this by assigning each individual to the cluster with the highest Q value. Let's assign the individuals to clusters for K = 3:
```{r}
# Assign individuals to clusters
clusters_k3 <- apply(qmat3, 1, which.max)
```

We can then plot the individuals on a map and color them by cluster. Let's plot the individuals on a map and color them by cluster for K = 2:

```{r map}
ggplot() +
  geom_point(data = liz_coords, aes(x = x, y = y, color = factor(clusters_k3)), size = 2) +
  theme_minimal() +
  labs(title = "K = 3", color = "Cluster") +
  scale_color_viridis_d(option = "turbo") +
  coord_quickmap()
```

Let's look at other K values
```{r map2}
clusters_k4 <- apply(qmat4, 1, which.max)
clusters_k5 <- apply(qmat5, 1, which.max)
clusters_k6 <- apply(qmat6, 1, which.max)

ggplot() +
  geom_point(data = liz_coords, aes(x = x, y = y, color = factor(clusters_k4)), size = 2) +
  theme_minimal() +
  labs(title = "K = 4", color = "Cluster") +
  scale_color_viridis_d(option = "turbo") +
  coord_quickmap()

ggplot() +
  geom_point(data = liz_coords, aes(x = x, y = y, color = factor(clusters_k5)), size = 2) +
  theme_minimal() +
  labs(title = "K = 5", color = "Cluster") +
  scale_color_viridis_d(option = "turbo") +
  coord_quickmap()

ggplot() +
  geom_point(data = liz_coords, aes(x = x, y = y, color = factor(clusters_k6)), size = 2) +
  theme_minimal() +
  labs(title = "K = 6", color = "Cluster") +
  scale_color_viridis_d(option = "turbo") +
  coord_quickmap()
```

QUESTION #: Another way we may try and assess the validity of clusters is whether they are geographically distinct; what this means is that individuals in the same cluster should be close to each other geographically. Based on this criteria, which K value do you think is the best? (You can pick multiple)

## Bonus: Interpolating ancestry coefficients across space

algatr can create interpolated maps of ancestry coefficient estimates using a method known as kriging, which uses a spatially explicit model for spatial interpolation. 

```{r raster, fig.align = 'center'}
# First, create a grid for kriging
# We can use one environmental layer (PC1), aggregated (i.e., increased cell size) to increase computational speed
krig_raster <- raster::aggregate(CA_env[[1]], fact = 6)
```


The `tess_krig()` function will take in ancestry coefficient values (in the Q-matrix) and will krige the values based on the raster provided (`krig_raster` from above). This will produce a Raster\* type object. First we need to do some manipulation of the coordinates to make sure they are in the correct projection.

```{r, cache = TRUE, results = FALSE, warning = FALSE}
# First, create sf coordinates (note: EPSG 4326 is WGS84/latitude-longitude)
coords_proj <- st_as_sf(liz_coords, coords = c("x", "y"), crs = 4326)

# Next, we project these coordinates to California Albers (EPSG 3310) since these coordinates are in California
coords_proj <- st_transform(coords_proj, crs = 3310)

# Finally, reproject the kriging raster to the same CRS as the coordinates
krig_raster <- projectRaster(krig_raster, crs = "epsg:3310")
# If you are using a SpatRaster you can reproject the coordinates like this:
# krig_raster <- terra::project(krig_raster, "epsg:3310")

# Now, we can run kriging using these coordinates
krig_admix <- tess_krig(qmat5, coords_proj, krig_raster)
```


Now let's explore how Q values (ancestry coefficients) are mapped. The `tess_ggplot()` function will take in the kriged admixture values and sampling coordinates (if the user wants points mapped), and provides several options for the plot method (with the `plot_method` argument):

-   `"maxQ"` plots only the maximum Q value for each cell (this is the default)

-   `"allQ"` plots all Q-values that are greater than a user-specified `minQ` value

-   `"maxQ_poly"` plots maxQ as polygons for each K-value instead of continuous Q values

-   `"allQ_poly"` plots allQ as polygons for each K-value instead of continuous Q values

```{r basic ggplot, fig.width = 5, fig.height = 5, fig.align = 'center'}
tess_ggplot(krig_admix, plot_method = "maxQ")
tess_ggplot(krig_admix, plot_method = "allQ", minQ = 0.20)
tess_ggplot(krig_admix, plot_method = "maxQ_poly")
tess_ggplot(krig_admix, plot_method = "allQ_poly", minQ = 0.20)
```


## Additional documentation and citations

------------------------------------------------------------------------

|                       | Citation/URL                                                                                                                                                                      | Details                                         |
|-------------------|-----------------------------|-------------------------|
| Main literature       | [Caye et al. 2016](https://onlinelibrary.wiley.com/doi/10.1111/1755-0998.12471); vignette available [here](https://bcm-uga.github.io/TESS3_encho_sen/articles/main-vignette.html) | Citation for TESS3                              |
| Associated literature | [François et al. 2006](https://academic.oup.com/genetics/article/174/2/805/6061653?login=false)                                                                                   | Details on algorithm used by TESS               |
| Associated literature | [Chen et al. 2007](https://onlinelibrary.wiley.com/doi/10.1111/j.1471-8286.2007.01769.x)                                                                                          | Details on algorithm used by TESS               |
| Blog post             | [Automatic K selection](https://chazhyseni.github.io/NALgen/post/determining_bestk/)       